	깃 활용하는 법
1.github 회원 가입을 하고 new repository 누르고 project 이름을 쓰고 만든다
2.git을 설치한다. (git과 github는 전혀 다르다)
3.git bash를 실행하고 첫번째는 git config --global user.name "NAME" 을 입력한다
4.두번째는 git config --global user.email "깃허브가입 이메일" 을 입력한다
5.잘입력됐는지 정보 확인하는법은 git config --list 를 입력하고 user name과 email을 확인해본다
6.git bash 에서 맨처음 올리때는 git init 을 입력한다. (:이 나오면 밑에 다 못나오고 짤렸다는 뜻 q를 눌러 빠져나온다)
	--> 이때 해당 폴더에 .git 폴더가 숨긴 폴더로 생긴다
7.git add 해당파일 위치 --> 해당 파일을 깃허브에 올리겠다(첫번째 단계)
	-->add . 은 해당 폴더의 모든 파일을 올리겠다
8.git status는 수정 내용이나 add 목록에 대한 내용이 나타난다
9.git commit -m "입력메세지 ex)first commit"
	-->commit은 히스토리를 만든다고 생각한다. 예를들면 과제완성(1) 에서 좀 더 보니 수정내용이 생기면서
	과제완성(2) 그 후 과제완성(3) 이런 식으로 갈 때, commit 을 한번 두번 하면서 변경사항을 수정하면서
	최종 버전을 만들어간다.
10.add 와 commit 을 통한 변경사항을 git 에서 github로 보낸다
	-->연결고리를 만든다. git remote add origin + 해당 레파지토리 주소입력해서 연결고리를 만든다
11.git remote -v 로 연결여부를 확인할 수 있다
12.즉 내 컴퓨터의 로컬 프로젝트와 주소를 입력한 github의 레파지토리와 연결 됐다는거다
13.git push origin master를 입력해서 origin 이름의 원격저장소의 master 브랜치로 보낸다
14.만약에 내 코드를 좀 바꾼다면? git add . 하면 된다. (이제는 git init 할 필요가 없다)
15.github 사이트에서 commit을 누르면 무엇이 수정되었는지도 볼 수 있다
16.github push 를 위해서는 로컬에서의 파일 위치를 잘확인해야한다. 상위 폴더로 가는 방법은 cd .. 을 입력한다
17.수정이 조금이라도 일어나면 add 와 commit 을 다시해야한다
18.터미널에서 : 이 뜨면 다 못나오고 밑에 짤렸다는 뜻. 방향키 아래를 누르거나 q를 눌러 빠져나온다
19.git clone url --> 원격저장소의 default branch를 로컬 저장소의 새로운 파일에 복사한다
20.git clone -b branchName url -->원격저장소의 특정 branch를 로컬저장소의 새로운파일에 복사한다


git config --global user.name "name"
git config --global user.email "email"
git config --list
git init 으로 폴더 설정( .git 폴더가 생긴다)
git add .
git status
git commit -m "message"
git remote add origin + github주소
git remote -v
git push origin master


------------------------------------------------------------------------
------------------------------------------------------------------------
1월22일
1.span은 inline이다. 활용하기
2.선택자 .box .list .li:nth-child(n)  -> 해당 클래스의 n번째 선택 확인하기
  ex).box .list .li:nth-child(1), .box .list .li:nth-child(4){margin:0}
	1,4번째만 margin 0으로 설정한다
3.box-sizing = border-box; 찾아보기
 ->width or height 를 입력하고 차지하는 공간을 계산할때, padding, margin, border의
	px 값을 합산한 값을 차지하도록 만든다. 즉 padding margin border 의 값들을 합산하여 
	width 값이 되도록한다. 
4.height를 최대한 자제할것
 ->컨텐츠의 크기에 따라 자동으로 정해지는 값을 사용한다
5.<ul>, <li> 태그 다시 한번 보기
 ->둘다 블럭 요소라고 생각하고, ul은 선수가 없는 목록들을 포함하는 큰 박스로 생각하고 그 안에서 수직으로 쌓인
	목록이 li 라고 생각하자
6.미디어쿼리
7.부트스트랩 3버전 사용하기(3,4,5버전 만들어진 기반이 다르다) + 참고내용은 w3schools 페이지에서 참고하기
grid system // modal(알림창)// dropdown
8.grid system -> container row col-sm-3 이라면 기본값 12칸 중에 각각 3칸을 합쳐서 총 4칸짜리로 만들어진다
9.커스터마이징 중요 - 영역 분할부터
10.웹폰트 적용 확인하기
 ->구글폰트에서 찾고, import를 이용해서 가져오고 
	@import url 을 적고,
	html, body{font-family: 'Sunflower', sans-serif; width: 100%; min-width: 320px;}
	를 부여한다
========================================================================================
1월23일
1.w3schools에서 dropdown 활용해보기/navbar search 활용하기/carousel 활용
	linear-gradient(to right(left...) 컬러) :자연스러운 색깔 변화
2.grid 와 modal 제일 중요
3..prod-list >li[class*=col-] 선택자를 지정할 때. 의미: list 클래스 밑에 있는 li태그중 col-이 들어간 모든것
4.index05(실습) 받아서 다시하기
5.https://parkinwook.github.io/TEST2.github.io/ 다시 확인하기
==============================================================

1월25일
자바스크립트
1.프로토타입 == 함수 기반이다
2.스크립트 언어 정의 찾아보기
3.ES5 와 ES6는 2015년 기준으로 크게 달라졌다
4.자바스크립트 공식 문서 MDN 으로 함수 의미 찾기(Reference -> JS)
5.console.log 단축키 설정하기 file -> prference -> snippets -> javascript
6.선언적 함수 선언에서 함수를 변수에 저장할 때 () 소괄호 주의
    var f = 함수명 -> f는 함수를 변수로 한다
7.익명함수 : 함수에 이름을 넣지않고(익명) 변수에 바로 선언한다
8.배열 정리하기 var arr = []; or var arr = new Array(); 소괄호 주의
9.향상된 for문 -> for var in arr -> 여기서 받는 변수는 index를 받으므로 
    arr[var] 로 추가적인 출력이 필요하다
10.전역변수, 지역변수를 정하는 것은 {} 가 아니라 함수 선언까지이다.
11.var x = {key:value} 는 오브젝트를 뜻한다. 
==============================================================================
1월29일
1.index04(실습문제) 다시풀기
2.innerHTML 은 태그 사이의 값을 변경한다
3.input type "checkbox" 와 태그.checked를 통한 체크 여부 확인
4.var sel = document.querySelector(".sel"); //select의 경우 value 가져오기 다시 확인하기(sel.value만 하면된다)
==============================================================================
1월30일
1.엘리먼트문자열(create text node)과 그냥 문자열 차이가 뭔가 찾기
	엘리먼트는 태그라고 생각하자
2.css에서 table 만들기 찾아 보기 <thead> <tbody> <tr> <th> <td>
3.input 태그에 size="" 으로 크기조절
4.함수 잘 만들기. 반복된다면 함수 떠올리기.
5.JS에서 노드가 뭔지 찾아보기
6. list.removeChild(list.firstElementChild); (+ 반복문으로 전체 지우기도 생각해보기)
=======================================================================================
1월31일
1.index09에서 옮길 행에대한 부모를 꼭 먼저 불러야한다. (var table = document.querySelector(".table");)
2.appendChild 와 함께 생각하기
3.index08에서 btn 버튼 만들고 add
4.이벤트객체 빡세게 보기
5.console.dir(태그) 활용하기
<CSS>
@ float:left 쓰기 위해서 부모영역에 overflow:hidden
@ 부모에 class 걸 때와 본인에게 직접걸 때 구분하기
@ 글자 두껍게 하기 ~~> font-weight: bolder;
@ 스크롤바 나오게 하기 ~~> overflow: auto;
@ 박스 안에 글자를 가운데 정렬하기 ~~> style="text-align:center"
@ 박스 자체를 가운데로 가져온다 ~~> margin: 0 auto;
==================================================================================================================
2월1일
1.index09(토글탭) 확인하기
2.drag이벤트에서 대상박스인지 타겟인지 정확하게 구분하기
3.event.preventDefault(); 드래그해서 놓으면 자동으로 실행되는 디폴트값을 막아줘야함
4.중요한 이벤트는 dragover 와 drop
=========================================================================================================
2월2일
1. <input type="submit" value="전송" id="btn">
2. JS MDN (공식문서) 에서 메서드 설명 참고할것
==========================================================================================================
2월6일
1.쿠키는 자바스크립트로도 생성하고 client에 저장할 수 있다
2.indexOf 함수 확인하기
3.date.setDate(~~) 함수 확인하기
4.쿠키생성을 통해 오늘하루동안 팝업창 띄우지 않기 만들기
5.세션과 쿠키 구분하기
6.JSON stringify, parse 다시 보기 (객체를 문자열로 만들어주고 문자열을 다시 객체로 만들면서 활용)
================================================================================================
2월7일
1.부모에 이벤트 위임하기
2.LocalStorage에 값을 배열에 넣고 사용할 때 JSON stringify와 parse 활용 잘하기
3.document.createElement(태그) 활용하기와 appendChild() 활용하기
4.동기 vs 비동기 (순차적으로 진행되는가? 동시에 여러 작업을 처리하는가?)
5.JSON 형식 or XML 형식으로 데이터를 주고받는다
6.AJAX 이용
	1) XMLhttpRequest 2)fetch 3)axios 4)JQuery의 AJAX
7.콜백함수 다시보기
8.DB 에서 join 한번더 복습하기
================================================================================================
2월8일
1. JS 에서 {}는 객체
	{key1 : value1, key2 : value2} 객체는 key 와 value 로 구성 되어있고 {}감싼다
2. SDK 검색해보기
3. swiper 에서 CDN 이용해서 활용하기
==========================================================================================
2월13일
1.라이브러리랑 프레임워크 차이
	라이브러리(모듈) : 함수와 같이 필요에 의해 미리 만들어 놓은 것. 리액트
	프레임워크 : Spring(JAVA), Vue 같이 미리 짜여진 뼈대, 틀, 규칙에 맞게 사용해야하는것. (라이브러리가 합쳐진)
2.선생님 수업자료 https://brave-planarian-384.notion.site/6c60785d267a439fb34ccb5953b08424?v=c6de239fb45b41019d14a6191f0e8a51
3.//배열.concat 찾아보기
	const arr3 = arr1.concat(arr2); -> 배열 두개 뒤로 합치기
	arr1, arr2 (원본 배열)은 변화 없다
4.console.log(person.age, person["age"]); //객체값에 접근하는 방법
5.Math.random()  찾아보기
	Math.floor(Math.random() * 10); -> 0 이상 10 미만
	Math.floor는 소수점 이하를 버린다

6.익명함수는 호이스팅 불가에서 호이스팅이란?
	변수와 함수 선언 사이에서 함수가 늦게 선언됐지만 끌어올려서 사용할 수 있다는 것이고
	일반 함수 선언에서는 가능하지만, 익명함수에서는 불가능하여 오류가 발생한다.
	익명함수는 함수를 변수에 선언한다
7.setInteval 보기
	콜백 함수를 일정 delay를 주면서 반복 실행하는 함수
	const A = setInterval(callback, delay); console.log(A); 로 실행
8.삼항연산자
	조건 ? a : b; 조건이 참이면 a 반환, 거짓이면 b 반환
============================================================================================================
2월19일
1.Maven 이란 무엇인가? 라이브러리를 받아서 사용하게해주는 node같은 느낌이랄까
====================================================================================================
2월20일
1.Spring의 가장 중요 스타트 개념. Dependency Injection
2.bean은 객체라고 생각하자
3.IoC컨테이너 미리 bean이라는 객체를 만들어 놓고, 프로젝트를 진행하는 과정에서
필요할 때 뽑아쓴다.(스프링설정파일)
4.DI : 스프링 Container 에 만들어둔 A 클래스(bean)가 B 클래스에게 의존적이다
B가 없으면 A가 실행안된다
5.생성자를 통한 의존객체 생성
6.Autowired 꼭 알아두기
	1타입으로 찾고, 이름으로 찾아서 자동주입
	2.생성자, 멤버변수, setter 에 사용이 된다
7.MVC2 모델. 모든 요청은 Controller 로 들어온다

8. 	1단계 모든 요청이 DispatcherServlet
	2단계 핸들러매핑이 URL을 분석하고 디스패치서블릿으로 리턴
	3단계 핸들러어댑터에게 그 분석내용 전달하고 적절한 컨트롤러를 다시 디스패치서블릿에게 디턴
	4단계 그 컨트롤러를 실행한다
	5단계 서비스+모델 를 거치고 데이터와 화면에 대한 내용을 디스패처서블릿에게 리턴
	6단계 뷰리졸버가 뷰에대한 경로 만들고 디스패처서블릿에게 제안
	7단계 디스패처서블릿이 뷰로 전달 Forward 방식

알고리즘================================================
1.제대로 만들고 배포했는데 왜이렇게 느려? 퀄리티가 왜이래? 관리하기 왜이렇게 힘들어?
-> 이때 알고리즘과 데이터베이스가 필요하다
2.알고리즘 : 여러개의 지시사항/스텝바이스텝/길찾기 어떻게 빨리, 효율적으로 갈까
3.데이터구조: 데이터를 어떻게 정리할 것인가. 서비스의 속도/정렬,검색,추가 등등
	검색 읽기 삽입 삭제 를 항상 염두해야한다
	가장 기본적인 배열부터 스타트!
	Time Complexity(시간복잡도) 실제 시간 측정이 아니라 얼마나 많은 steps이 있는가
4.메모리 관점 휘발성 메모리(RAM) vs 논휘발성 메모리(HardDrive)
	컴퓨터를 끄면 데이터가 사라진다/ RAM이 데이터를 빨리 읽는다
	RAM : 데이터가 저장된 주소에 랜덤하게 접속 할 수 있기 때문에 
		1번,2번,3번 주소로 순차적으로 접속하는게 아니라 13번 주소로 한방에 접근할 수 있다

5. Reading - 배열의 경우 시작위치와 크기를 알고있기 때문에 데이터를 읽어내는 속도와 스텝이
	가장 빠르다
6. Searching - 값이 있는지, 어딨는지도 모름 -> 0번부터 박스를 다 열고 찾아봐야함
		값이 없는 경우도 있다! --> 선형검색
7. Insert - 공간을 미리 선언해야한다. 데이터를 삽입하려고하면 마지막 빈공간으로 한칸씩
		옮기고 넣어야하므로 길어진다
		더 최악은 미리 선언한 공간이 꽉 찬 경우 -> 새 배열 선언, 요소 복사, 옮기고 추가하고
		좋지않다
8. Delete - Insert와 비슷하다. 끝을 삭제하면 끝. 중간을 삭제하면 뒤에 값들을 떙긴다
		최악은 첫번쨰 요소를 삭제하면 전부다 앞으로 한칸씩 움직여야한다

즉! Reading 에는 배열이 빠르고 좋다. 나머지에는 좋지 않다!
	
	

