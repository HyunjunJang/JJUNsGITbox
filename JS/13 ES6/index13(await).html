<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Document</title>
</head>

<body>

   <script>
      const func1 = () => {
         return new Promise((resolve, reject) => {
            setTimeout(() => {
               resolve('success55555')
            }, 5000)
         })
      }
      const func2 = () => {
         return new Promise((resolve, reject) => {
            setTimeout(() => {
               resolve('success22')
            }, 2000)
         })
      }
      const func3 = () => {
         return new Promise((resolve, reject) => {
            setTimeout(() => {
               resolve('success333')
            }, 3000)
         })
      } //

      //비동기적 실행이므로 순서 보장을 받을 수 없다 
      // func1().then((data)=>console.log(data)) //5초
      // func2().then((data)=>console.log(data)) //2초
      // func3().then((data)=>console.log(data)) //3초
      //=> 콜백지옥을 통한 순서 보장이 가능

      //async는 return을 promise로 바꾼다.
      //await -> 1.async 안에서만 사용가능 2.return이 promise인 경우에만 사용 가능
      //         3.await이 적용되면 then절을 생략하고 결과를 바로 받을 수 있다
      ( async function () {
         let result = await func1();
         console.log(result);

         let result2 = await func2();
         console.log(result2);

         let result3 = await func1();
         console.log(result);

      })()

      const myFetch = async () => {
         return "data";
      }
      let result = myFetch() //promise객체
      console.log(result)
      

      
   </script>
</body>

</html>