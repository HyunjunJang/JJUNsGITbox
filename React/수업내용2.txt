2월14일======================================================
1.termical에 원하는 폴더에 npm create react-app 프로젝트명(react-basic) 입력
2.컴포넌트는 재활용이 필요한 것들 (함수,클래스,js파일..)
3.최상위는 App.js 로 생각
4.props : 부모컴포넌트에서 자식컴포넌트로 내려주는 변수
5.import를 바로 할 때, 컨트롤+스페이스
6.state값 변경시 화면이 다시 그려진다. 리렌더링 진행!
  ->자식 컴포넌트에서 값이 변하는 변수를 선언할 때 생각한다
  ->state[변수, 함수] = useState('초기값');
  ->함수로 변수값을 변경해야한다
7.setData() 함수는 비동기적인 실행이다(순서대로 실행되지 않는다)
8.컴포넌트는 대문자 시작한다 / 프로젝트명은 소문자로만
9.import한 함수 불러내기  -> <함수명/>
10.props는 상위컴포넌트에서 하위컴포넌트로 전달하는 매개변수(객체로전달)
  <자식컴포넌트 name={} ... /> 해서 자식컴포넌트에 name 매개변수를 전달
  자식컴포넌트 ( {name, ...} ) 매개변수 받는 방법
  (상위)<MyComponent name={"홍길동"} age={2} email={"aa@naver.com"}/>
  (하위)const MyComponent = ( {name, age, addr, email} ) => { }
  ================2월15일============================
1.select 태그는 + option 을 건다 
  -> 이벤트 거는건 select 태그에 건다(ex피자)
2.const newObj = {...data} 이면 'data객체'를 복사해서 새로운 객체 newArr를 만든다
  -> 여기서 객체 값변화를 {a:'', b: '', a:'aa'} 라고하면 key a값이 바뀐다
  -> let value = {...data, [e.target.name] : e.target.value};
3.e.target은 이벤트가 발생하는 엘리먼트를 뜻하고 즉, 태그를 가리킨다고 생각하자
4.input 태그에서 value 의미 한번 더 찾아보기
  -> e.target으로 input 태그를 가리킬때 e.target.value로 입력한 값을 호출한다
8.map함수 찾아보기
  (1)배열에 반복문이 필요한 경우 사용하는 함수
  (2)각 요소들을 꺼내서 호출하고 그 값을 매개변수로 받는 콜백함수를 적용하고 그 결과로 이루어진
  새로운 배열을 만들어준다.
9.filter함수
  (1)배열의 각요소에 특정 조건문을 적용하여 뽑아낼때
  (2)콜백함수의 조건이 true이면 새로운 배열에 포함하고 아니면 버린다
9.콜백함수는 쉽게 함수안에 매개변수가 함수인 경우라고 생각하자
10.style 줄때는 {{}} 활용하고 display : "flex" 확인하기 justify~~space~~
11.useEffect( () => {콜백함수},[배열선언])
   (1)[배열]을 공백으로 하면 첫 mount 될 때 실행되고, [공백] 이므로
   업데이트가 계속 되어도 더이상 실행되지 않는다
   (2)콜백함수 내에서 [배열] 값이 변경되면 무한루프에 빠진다
   업데이트가 되면 콜백함수에서 배열이 바뀌었다고 생각되어서
   리렌더링이 진행되고 또 반복된다.

========2월16일==============
1.index.js 밑에 app.js 밑에 component.js들이 있다.
   html은 index.html 파일 하나만 있다.
2.SPA는 하나의 페이지만 이용한다. 라우팅 라이브러리를 활용해서 사용자가 페이지가
   여러개인것 처럼 느끼게 한다
3.쿼리스트링으로 넘겨준 키값을 useLocation, useSearchParam
4.구조분해할당 다시 보기
   (1)반대로 지정한다  let { name , b , c} = obj;
   (2)key 값을 변수명으로 맞춰줘야한다. 위에서 b, c 는 언디파인 상태
5.중첩라우팅 신기하네
6.alt 클릭으로 한번에 글자 고치기
7.참견하지말자
8.Ajax 다시 보기
  (1)비동기적으로 서버에 데이터를 request 하고 response 한다 (비동기적 = 순서가 없다)
  (2)Fetch API를 이용한다 
    (a)Promise를 기반으로 한다
    (b)fetch('서버주소 URL') -> 해당 URL에 HTTP 요청을 한다. 이는 Promise를 반환한다
    (c)반환된 promise.then( (response) => response.json() ); 를 통해 json데이터를 javascript 객체 타입으로 파싱한다
    (d)해당 결과.then( data => console.log(data)); 하면 결과값을 콘솔창에 출력한다
10. && 왜 쓰는가 한번더 찾아보기
  (1) A && B 는 해당 코드가 실행되는 과정에서 A가 false일 때 그 뒤 코드인 B가 실행되지 않도록 한다
11.비동기에서 순서대로 진행을 위해 콜백함수를 이용한다
  콜백지옥이 나타나기때문에 async, await을 통해 해결 가능
============2월19일================================================
1.프로미스 객체 찾아보기, .then(콜백함수) , 더 쉽게 사용하게해주는 async, await 규칙 보기
2.Ref 훅